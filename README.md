# **Network RAID Filesystem**

## Running instructions

**./net_server.o [address] [port] [server path]**

**./net_client.o [config file path]**

# Design Document

Network RAID filesystem არის FUSE-ზე დაწერილი ქსელური ფაილსისტემა, რომელიც (ამ შემთხვევაში) იყენებს RAID1 სქემას და სხვადასხვა მეთოდებით უზრუნველყოფს მონაცემთა დაცვასა და აღდგენას.

### **Config Parser**

პარსერი არის პროგრამის ის ნაწილი, რომელიც კონფიგურაციის ფაილიდან კითხულობს საჭირო ინფორმაციას რათა მოხდეს პროექტის გაშვება და დაყწება. იგი გამოიყენება მხოლოდ კლიენტის მიერ და იღებს ყველანაირ ინფორმაციას ფაილსისტემის დამაუნთებისა და მუშაობის უზრუნველყოფისთვის.</p>

<p>გვაქვს parser.c და parser.h ფაილები. ინფორმაცია დავყავი ორ ნაწილად, პირველში თვითონ კონფიგურაციის ინფორმაცია ინახება. მეორე კი არის დისკების სტრუქტურების მასივი. ამისათვის გამოვიყენე შემდეგი სტრუქტურები:

```C
struct config 
{
	char* errorlog;
	char* cache_size;
	char* cache_replacment;
	char* timeout;
};
```

```C
struct disk 
{
	char* diskname;
	char* mountpoint;
	char* raid;
	char** servers;
	int servers_size;
	char* hotswap;
};
```

ასევე გვაქვს ცვლადი, რომელიც ადვილად ხელმისაწვდომია: int DISK_COUNT; რათა კლიენტში ზუსტად ვიცოდეთ რამდენი დისკია მოცემული. ასევე მეთოდები: int configure(char* name); რომელიც ფაილის სახელის მიხედვით ახდენს ინიციალიზაციას. struct config * get_config(); რომელიც აბრუნებს კონფიგ სტრუქტურას და struct disk ** get_disks(); რომელიც დისკების მასივს აბრუნებს. კლიენტის მეინი იწყება configure (argv[1]);-ით. მშობელი კლიენტის პროცესი ინახავს ინფორმაციას კონფიგ სტრუქტურიდან შესაბამის ცვლადებში. შემდეგ კი DISK_COUNT რაოდენობის პროცესი იძახება და თითოეული იღებს ინფორმაციას შესაბამისი ინდექსის მქონე დისკიდან.


### **Client/Server Structures and Variables**

თითოეული დისკისათვის კლიენტის სერვერებთან ურთიერთობის საკონტროლოდ ერთ-ერთი საშუალებაა int indx = -1; იგი განსაზღვრავს თუ რომელი სისტემ ქოლი უნდა გადატვირთოს სერვერმა. მისი გადაცემა ხდება მეთოდიდან send_essentials, საიდანაც ასევე გადაეცემა path, და სხვა ფუნქციონალისთვის საჭირო ინფორმაცია, რომელიც ყველა სისქოლს საერთო აქვს.

კლიენტის მხარეს სერვერთან დაკავშირება და ინფორმაციის ამოღება კონფიგურაციის ფაილიდან ხდება მეინში, კონკრეტულად კი disk_main-ში, რომელიც თითოეული დისკისთვის ეშვება. გლობალურად დისკის ინფორმაცია ინახება შემდეგ სტრუქტურაში:

```C
struct server_info {
	int sfd;
	struct sockaddr_in * addr;
	char* full_address;
};
```

struct server_info servers[2]; კი არის მასივი, რომელიც დაწერილია კონკრეტულად raid1-ისთვის, რადგან raid5-ის იმპლემენტაცია არ არის დაწერილი. servers[0] არის მთავარი სერვერი,  servers[1] კი მეორადი, ამ ფაქტს რეიდ1-ის აღწერისას დავუბრუნდებით.  full_address ინახება ლოგირებისთვის.

ასევე აღწერილია struct sockaddr_in addr_hs; და char * full_hs_addr; სადაც ჰოთსვეფის ინფორმაცია ინახება რათა მარტივად მოხდეს მასთან დაკავშირება როცა საჭირო ხდება. int swap_on; გვეხმარება სერვერის აღდგენის რეგულირებაში როცა ინფორმაციის გაცვლაა საჭირო.

int last_fd; გამოიყენება მეორად სერვერზე არსებული ბოლოს გახსნილი ფაილ დესკრიპტორის შესანახად.

სერვერის მხარეს გვაქვს ეპოლისა და კლიენტის ფაილდესკრიპტორები და ასევე გადატვირთული სისტემქოლების შესაბამისი ინდექსები და სია:

```C
#define GETATTR 0
#define OPENDIR 1
#define READDIR 2
#define RELEASEDIR 3
#define MKNOD 4
#define MKDIR 5
#define RMDIR 6
#define UNLINK 7
#define RENAME 8
#define TRUNCATE 9
#define OPEN 10
#define READ 11
#define WRITE 12
#define RELEASE 13
#define CHMOD 14
#define UTIME 15
```

### **Raid1**

კლიენტი და სერვერი მოცემულია სოკეტების სახით, კლიენტი ემსახურება ფაილსისტემის მაუნთფოინთს, სერვერის თითოეული პროცესი კი სთორიჯს. სთორიჯი არის ის დირექტორია, სადაც რეალურად ინახება ინფორმაცია, თითოეული დირექტორია, ფაილი და ა.შ. ჩვენს მაუნთფოინთს კი ეს ყველაფერი იქიდან მოაქვს და აძლევს საშუალებას კლიენტს ჰქონდეს სრული კონტროლი.

რეიდ1 არის სთორიჯის მენეჯმენტის ალგორითმი, რომელიც ინფორმაციის დისკის ორ სერვერზე კოპირებას მოიცავს. როდესაც ერთ-ერთ სერვერზე ფაილი ზიანდება, აღდგენა ხდება მეორე დისკიდან.

ფაილ სისტემის იმპლემენტაციისთვის შემოღებული მაქვს მთავარი სერვერის მცნება. ინფორმაციის ჩაწერა ხდება ორ სერვერზე, ხოლო კითხვა ხდება მხოლოდ მთავარი სერვერიდან. მთავარი სერვერი აღნიშნულია 0 ინდექსით სერვერების მასივში, ანუ სერვერი რომელიც პირველ ინდექსზე მოხდება არის ყოველთვის მთავარი.

კონკრეტულად ამ ალგორითმის იმპლემენტაციისთვის კი გამოიყენება სთეიბლ სთორიჯის მექანიზმი. როდესაც იქმნება ფაილი ან არსებულ ფაილში ხდება რამის ჩაწერა, ინახება მისი ჰეში, ამისთვის გამოყენებულია სტანდარტული MD5 ჰეშირებისა და ბიბლიოთეკის მეთოდები. შემდეგ ეს ჰეში ინახება ფაილის ატრიბუტად setxattr მეთოდის მეშვეობით. ხოლო როდესაც ფაილის გახსნა ხდება, ერთმანეთს ედარება ჩაწერილი და წაკითხული ჰეშები, ორივე სერვერის მხარეს. და ბოლოს ერთმანეთს ედარება ორივე სერვერზე წაკითხული ფაილების ჰეშები. ეს შედარება ხდება კლიენტის მხარეს, კლიენტი წყვეტს რომელი სერვერიდან რომელ სერვერზე უნდა მოხდეს გადაწერა. უგზავნის შესაბამის int ცვლადს სერვერებს და თავის მხარეს უშვებს rewriter (int receiver, int sender) მეთოდს, რომელსაც გადაეცემა მიმღები და გამგზავნი სერვერების დესკრიპტორები. სერვერი კითხულობს ფაილს და თითოეული ჩანქის მერე კლიენტის მეშვეობით აწვდის ბაფერს მეორე სერვერს რათა იქ მოხდეს შესაბამის ფაილში ინფორმაციის ჩაწერა. საგულისხმოა, რომ ჩაწერის წინ ფაილი რესეტდება თრანქეით ფლეგის მეშვეობით რათა მოხდეს ფაილის 100% ზუსტი კოპირება. ამისთვის გამოიყენება void my_read(char * full) და void my_write(char * full) მეთოდები.


### **Server Disconnection and Hotswap**

ფაილსისტემაში ასევე იმპლემენტირებულია მაღალმდგრადობა. მუდმივი მთავარი სერვერის ქონის იდეა აქ არის გამოყენებული. როდესაც სერვერი ითიშება, თუ იგი მთავარი სერვერი იყო, მაშინვე ხდება სერვერებისთვის როლებისა და ინფორმაციის გაცვლა. დარჩენილი სერვერი ხდება ახალი მთავარი სერვერი და ჩვეულებრივ აგრძელებს მუშაობას, ხოლო მეორადი სერვერი ინაცვლებს შემდეგ ეტაპზე, რაც გულისხმობს ან თავიდან დაკავშირებას ან ჰოთსვეფით ჩანაცვლებას.

როდესაც სერვერი ითიშება, კლიენტი timeout წამის განმავლობაში ცდილობს მასთან დაკავშირებას. სერვერის გათიშვისას ხდება SIGPIPE და შესაბამისად იმის გარკვევა გათიშულია თუ არა სერვერი ხდება EPIPE ერორის დაჭერით. ეპაიპის დასაჭერად სოკეტის send ფუნქციას მე-4 პარამეტრად გადაეცემა MSG_NOSIGNAL. როდესაც სენდი დაეორდება თაიმერი ჩაირთვება და ყოველი სისტემ ქოლის დროს მოწმდება timeout დრო ხომ არ არის გასული.

სანამ ეს დრო გავა, კლიენტი ცდილობს მკვდარ სერვერთან connect-ს, თუ კი სერვერმა დადებითად უპასუხა და წარმატებით მოხდა დაკავშირება, თაიმერი გამოირთვება და ირთვება სერვერის აღდგენის, ანუ ახლად დაკავშირებულ სერვერზე პირველის ინფორმაციის გადაწერის, რეჟიმი. შემდეგ კი ჩვეულებრივად გრძელდება მუშაობა.

თუ დრო გასულია, მაშინ ანალოგიურად ცდილობს სერვერი ჰოთსვეფ სერვერთან დაკავშირებას. ამასთანავე, ჰოთსვეფის ინფორმაცია იწერება servers მასივში ინდექს 1-ზე, ანუ იგი ავტომატურად მეორად სერვერად გამოცხადება და ირთვება სერვერის აღდგენის რეჟიმი, სხვაობა ისაა რომ მეორადი სერვერი ამჯერად ჰოთსვეფია.

ზემოთ მოცემულ ორივე შემთხვევაში გადაწერა ხდება მთავარიდან მეორე სერვერზე. სერვერის client_handler()-ს მისდის შეტყობინება (ბულეანი) რომ სერვერის აღდგენაა ჩართული და იძახება მეთოდი server_refill (); იგი არის ორივე სერვერსა და ასევე კლიენტზე რეკურსულად იმპლემენტირებული მეთოდი.

მთავარი სერვერი: იძახება ფაილის მისამართზე, stat ფუნქციის მეშვეობით ხდება გარკვევა მისამართი დირექტორიაა თუ რეგულარული ფაილი.

თუ ეს მისამართი დირექტორიაა, ხდება დირექტორიის წაკითხვა, თითოეული სახელი ვარდება მასივში. ამ მასივის ზომა ეგზავნება კლიენტს, რომელიც თავის მხრივ უგზავნის მეორად სერვერს. შემდეგ მთავარი სერვერი გადაუყვება ამ მასივს, თითოეული სახელი ეგზავნება კლიენტს. ამავდროულად კვლავ ირკვევა ეს სახელი დირექტორიას ეკუთვნის თუ ფაილს და კლიენტს ეგზავნება is_dir თითოეულ სახელთან ერთად. თუ ფაილია ირთვება გადაწერის რეჟიმი. ყოველ სახელზე რეკურსია სიღრმეში ჩადის.

ხოლო თუ ფაილია, კლიენტს ეგზავნება რომ მოხდა 0 რაოდენობის ფაილის წაკითხვა და რეკურსიის სიღრმეში აღარ ჩადის.

კლიენტი: კლიენტი ფორ ციკლით იღებს ფაილის/დირექტორიის სახელსა და is_dir-ს, ორივეს უგზავნის მეორად სერვერს და თუ ფაილია რთავს გადაწერის რეჟიმს.

მეორადი სერვერი: იღებს კლიენტიდან ამ ინფორმაციას ასევე ფორ ციკლში. თუ დირექტორიაა, იძახება mkdir სისქოლი, ხოლო თუ ფაილია mknod და ფაილის აღმდგენი. თითოეულ იტერაციაზე რეკურსია ჩადის სიღრმეში.


### **Cache**

ფაილების კითხვის დასაჩქარებლად ფაილსისტემას აქვს იმპლემენტირებული ქეშირების მექანიზმი. როდესაც ერთიდაიმავე ფაილზე მეორედ ან მეტჯერ ხდება მიმართვა, სერვერიდან წაკითხვის ნაცვლად ხდება ადგილობრივი ქეშიდან ინფორმაციის ამოღება. ქეშირებისთვის გამოყენებულია სტანდარტული LRU ალგორითმი.

ქეშირების ლოგიკა აღწერილია cache.h და cache.c ფაილებში. ქეში იმპლემტირებულია ორმაგი ბმული სიით. ბმული სიისთვის საჭირო სტრუქტურები აღწერილია შემდეგნაირად:

```C
struct cnode 
{
	char* path; 
	char* buf; 
	size_t size; 
	off_t offset;
	int fd;
	struct cnode* prev;
	struct cnode* next;
};
```

ნოუდის სტრუქტურა ინახავს ფაილის ინფორმაციას და შემდეგ და წინა ნოუდზე მიმთითებლებს.

```C
struct cqueue 
{
	int count;
	size_t q_size;
	int capacity;
	struct cnode* head;
	struct cnode* tail;	
};
```

ქიუს სტრუქტურა ინახავს სიის თავსა და კუდს. ასვე ინახავს ელემენტების რაოდენობას, ელემენტების ჯამურ ზომას და მაქსიმალურ ზომას: capacity-ს, რომელსაც კონფიგურაციის ფაილიდან ვიღებთ.

ქეშში იმპლემენტირებულია შემდეგი ფუნქციები: struct cqueue* init_queue (int capacity); და struct cnode* create_data (const char* path, char* buf, size_t size, off_t offset, int fd); პირველის მეშვეობით ხდება ლისტის ინიცალიზაცია და ინახება capacity. ეს მეთოდი გამოიყენება კლიენტის გაშვების დასაწყისში. ხოლო მეორე გამოიყენება თითოეული ნოუდის შევსებისათვის შესაბამისი ფაილის ინფორმაციით.

int add_front (struct cqueue* queue, const char* path, char* buf, size_t size, off_t offset, int fd); სიის თავში ამატებს ახალ ელემენტს. თუ ქეში გადავსებულია, სიის ბოლოდან იშლება ელემენტი. საგულისხმოა, რომ სიის ბოლოს ყველაზე ადრე გამოყენებული ბლოკებია. ქეშის გადავსება მოწმდება ზომის capacity-სთან შედარებით.

int remove_rear (struct cqueue* queue); არის მეთოდი რომელიც სიის ბოლოდან შლის ელემენტს, იგი გამოიძახება ქეშის გადავსების დროს.

struct cnode* find_node (struct cqueue* queue, const char* path, off_t offset); ეძებს ნოუდს სიაში, წევს მას სიის თავში და თან აბრუნებს, რათა კლიენტმა შეძლოს ბაფერის ამოღება. ძებნა ხდება შემდეგნაირად: სია თავიდან ბოლოსკენ გადაუყვება ყველა ნოუდს და ადარებს მათ path და offset-ის მიხედვით. თუ არ მოიძებნა ნოუდი, ბრუნდება NULL.

int delete_by_path (struct cqueue* queue, const char* path); გადაუყვება მთელ სიას და შლის ყველა ნოუდს, რომელსაც მოცემული მისამართი ეკუთვნის. ანუ რეალურად ქეშიდან ასუფთავებს კონკრეტულ ფაილთან დაკავშირებულ ბლოკებს. მისი გამოძახება ხდება ფაილის შეცვლის ან წაშლის დროს.

ქეშის ალგორითმი შემდეგია, ფაილის წაკითხვისას ხდება find_node, თუ არ მოიძებნა, ჩვეულებრივად გრძელდება წაკითხვა და შედეგი იწერება ქეშის თავში. თუ ქეში სავსეა, add_front შლის ნოუდს ბოლოდან (rlu). თუ მოიძებნა, ავტომატურად გამდმოდის სიის თავში (როგორც ბოლოს გამოყენებული) მოცემული ელემნტი და რიდის ბაფერში კოპირდება ქეშირებული ბაფერი.


### **Epoll API**

ეპოლი ახდენს ფაილ დესკრიპტორებისა და მათზე მომხდარო ინფუთ/აუთფუთის მონიტორინგს. უზრუნველყოფს მათ უფრო სწრაფ და ოპტიმალურ მუშაობას, განსაკუთებით როდესაც რამდენიმე ფაილ დესკრიპტორია. ჩვენი ფაილსისტემის შემთხვევაში ეპოლი გამოიყენება სერვერების მხარეს და აკვირდება კლიენტის ფაილ დესკრიპტორს.

ჯერ იქმნება ეპოლის ფაილ დესკრიპტორი epoll_create()-თი, შემდეგ ივსება epoll_event, epoll_ctl()-ში ემატება კლიენტის ფდ, და ხდება ეპოლის ფდ-ზე epoll_wait();


### **Logging**

ლოგირება იმპლემტირებულია log.h და log.c ფაილებში. 
int log_initialise (char* log_path); ხსნის კონფიგურაციის ფაილში მითითებულ ლოგ ფაილს ფაილ დესკრიპტორით, ხოლო int log_close (int fd); ხურავს ამ ფაილ დესკრიპტორს. ფაილში ჩაწერისათვის გამოიყენება dprintf, რომელიც წერს ფაილში ფაილ დესკრიპტორის მიხედვით.

გვაქვს მეთოდი int log_time () რომელიც მთლიანად უზრუნველყოფს დროისა და თარიღის დაბეჭდვას და გამოიყენება ყველა სხვა ლოგირების მეთოდის მიერ. იგი იყენებს time და localtime-ს რათა დათვალოს epoch-ის მერე გასული დრო time_t ფორმატით. შემდეგ კი გამოიყენება strftime რათა მიღებული დრო სტრინგად დაკონვერტირდეს მითითებული ფორმატის მიხედვით. 

int log_function (char* diskname, char* full_addr, char* format, ...)  ფუნქცია წერს დისკის სახელს, სერვერის სრულ მისამართს და ახდენს ფუნქციის (ან ქეშის) ლოგირებას.  char* format-ის სახით გადმოეცემა ცვლადების დაბეჭდვის ფორმატი, ხოლო შემდეგ კონკრეტული პარამეტრები რომლითაც ისინი ივსება. მათ ჩაწერას უზრუნველყოფს vdprintf(). ასევე გვაქვს log_result() რომელიც ბეჭდავს დაბრუნებულ სტატუსს ან ერრნოს თუ ერორი დაბრუნდა. 

გვაქვს log_server (char* diskname, char* server, char* full_addr, int sfd) ფუნქცია, რომელიც აღწერს სერვერის ან ჰოთსვეფის დაკავშირება/გათიშვას.

ლოგირება ხდება ყოველი სისტემ ქოლის გამოძახებისას და მათი შედეგის დაბრუნებისას. ასევე სერვერების გათიშვა/დაკავშირებისას და ქეშში დამატების/ქეშიდან წაკითხვისას.
